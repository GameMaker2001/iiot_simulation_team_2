This project is a simulation of an Industrial Internet of Things (IIoT) network. We built a system that generates fake sensor data (temperature and humidity) and sends it across different communication protocols like MQTT, CoAP, and OPC UA. The goal was to see how these industry standards handle data and to visualize that data in real-time using Python.

Rather than relying on a single communication method, this simulation implements three major industrial protocols—MQTT, CoAP, and OPC UA—to demonstrate their unique architectural strengths and operational differences. MQTT serves as our primary data stream due to its lightweight "publisher/subscriber" model, while CoAP is utilized to show how constrained devices handle "request/response" interactions. Finally, OPC UA is integrated to represent the high-security, server-client standard commonly found in complex industrial automation settings.

[INSTRUCTIONS]
To successfully execute the full simulation, you must manage four separate terminal windows simultaneously to ensure each component of the network can communicate. First, you must establish the environment by navigating to the project folder, creating a virtual environment with py -m venv venv, activating it via venv\Scripts\activate, and installing the necessary libraries including pandas, paho-mqtt, aiocoap, asyncua, and matplotlib. Once the environment is ready, the simulation begins by launching the MQTT Broker (the "Post Office" for data) in the first terminal by running mosquitto.exe -v from the Mosquitto installation directory.

With the broker active, you can then start the data producers in separate terminals by activating the virtual environment and running python mqtt_sensor_simulation.py and python opcua_sensor_simulation.py. These scripts will begin generating and broadcasting simulated temperature and humidity readings. The final step is to launch the dashboard in a fourth terminal using python data_visualization.py. This script functions as the system's "Main Thread," subscribing to the MQTT broker and utilizing Matplotlib to generate a live, refreshing graph of the incoming sensor data.

Troubleshooting and File Structure
The project is organized into specific scripts for each protocol, alongside a dedicated visualization file and a formal comparison report in PDF format. If you encounter a "Connection Refused" error, it is usually because the Mosquitto broker in the first terminal was closed or failed to start. Similarly, if the graph window terminates prematurely, ensure that the visualization script is being run in its own dedicated terminal to prevent thread conflicts. Most "Module Not Found" errors are easily resolved by confirming that the virtual environment has been activated in that specific terminal window before executing the Python command.
